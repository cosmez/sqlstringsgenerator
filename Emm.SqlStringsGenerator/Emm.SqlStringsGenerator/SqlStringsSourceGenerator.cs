using System;
using System.IO;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace Emm.SqlStringsGenerator;

[Generator]
public class SqlStringsSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        // No initialization required for this generator.
    }

    public void Execute(GeneratorExecutionContext context)
    {
        var files = context.AdditionalFiles.Where(at => at.Path.EndsWith(".sql"));
        foreach (var file in files)
        {
            CreateSqlClassSource(context, file);
        }
    }

    private void CreateSqlClassSource(GeneratorExecutionContext context, AdditionalText file)
    {
        var queries = ParseSqlStrings(context, file);

        //we should at least declare the --class name in order to use this file
        if (!string.IsNullOrWhiteSpace(queries.ClassName))
        {
            var sb = new StringBuilder();
            sb.AppendLine($"// <auto-generated/>");
            sb.AppendLine($"namespace {queries.Namespace};");
            sb.AppendLine($"{queries.ClassModifier} class {queries.ClassName}");
            sb.AppendLine("{");
            foreach (var query in queries.Queries)
            {
                sb.AppendLine($"    {queries.Modifiers} {query.Key} = @\"\"\"");
                sb.AppendLine(query.Value);
                sb.AppendLine("\"\"\";");
            }

            sb.AppendLine("}");


            string sourceString = sb.ToString();
            var sourceText = SourceText.From(sourceString, Encoding.UTF8);
            context.AddSource($"SqlStrings{queries.ClassName}.g.cs", sourceText);
        }
    }
    
    private (string directive, string value) ParseDirective(string line)
    {
        int it = 2;
        while (it < line.Length && line[it] != ':') it++;
        var directive = line.Substring(2, it-2);
        string value = string.Empty;
        if (directive.Length < line.Length)
        {
            value =  it == line.Length ? line : line.Substring(it+1);
        }

        return (directive, value);
    }

    private SqlClassQueries ParseSqlStrings(GeneratorExecutionContext context, AdditionalText file)
    {  
        SqlClassQueries sqlClassQuery = new();
        using TextReader reader = new StreamReader(file.Path, Encoding.UTF8);
        
        var sb = new StringBuilder();
        string queryName = string.Empty;
        
        while (reader.ReadLine() is { } line)
        {
            // Process the line
            if (line.Length > 2 && line[0] == '-' && line[1] == '-')
            {
                (var directive, var value) = ParseDirective(line);
                if (value.Length == 0)
                {
                    //no way to autoinfer name for now
                }
                else
                {
                    if (directive == ("namespace")) sqlClassQuery.Namespace = value.Trim();
                    if (directive == ("class")) sqlClassQuery.ClassName = value.Trim();
                    if (directive == ("classModifiers")) sqlClassQuery.ClassModifier = value.Trim();
                    if (directive == ("modifiers")) sqlClassQuery.Modifiers = value.Trim();
                    if (directive == ("name"))
                    {
                        if (sb.Length != 0 && queryName != string.Empty)
                        {
                            if (!sqlClassQuery.Queries.ContainsKey(queryName))
                                sqlClassQuery.Queries.Add(queryName, sb.ToString());
                        }
                        queryName = value.Trim();
                        sb.Clear();
                    }
                    
                }
            } else if (line.Length > 0)
            {
                sb.AppendLine(line);
            }
 
        }
        
        //last query in the file
        if (sb.Length != 0 && queryName != string.Empty)
        {
            if (!sqlClassQuery.Queries.ContainsKey(queryName))
                sqlClassQuery.Queries.Add(queryName, sb.ToString());
        }
        
        sb.Clear();
        return sqlClassQuery;
    }


    private SqlClassQueries ProcessSqlFile(SourceText source)
    {
        (string option, string value) GetOption(string line)
        {
            string[] values = line.Replace("--", "").Trim().Split(':');
            return (values[0].Trim(), values[1].Trim());
        }

        SqlClassQueries sqlOptions = new();
        //every line until the first non commented line is an option
        bool parsingOptions = true;
        string lastQueryName = string.Empty;
        var sb = new StringBuilder();
        for (int i = 0; i < source.Lines.Count; i++)
        {
            var line = source.Lines[i].ToString().Trim();
            var line2 = source.Lines[i];
            if (parsingOptions)
            {
                if (line == "") parsingOptions = false;
                if (line.Contains(':') && line.StartsWith("--"))
                {
                    var option = GetOption(line);
                    if (option.option == "namespace")
                    {
                        sqlOptions.Namespace = option.value;
                    }

                    if (option.option == "class")
                    {
                        sqlOptions.ClassName = option.value;
                    }
                }
            }


            if (!parsingOptions && line.StartsWith("--") && line.Contains(':'))
            {
                var option = GetOption(line);
                if (option.option == "name")
                {
                    //first we save the previous query, with the previous name
                    if (!string.IsNullOrEmpty(lastQueryName))
                    {
                        sqlOptions.Queries.Add(lastQueryName, sb.ToString());
                        sb.Clear();
                    }

                    //then we continue with the new name
                    lastQueryName = option.value;
                }
            }

            if (!parsingOptions && !string.IsNullOrEmpty(lastQueryName) && !string.IsNullOrEmpty(line))
            {
                sb.AppendLine(line);
            }

            if ((i + 1) == source.Lines.Count) //is this the last line?
            {
                //save the last query
                if (!string.IsNullOrEmpty(lastQueryName))
                {
                    sqlOptions.Queries.Add(lastQueryName, sb.ToString());
                    sb.Clear();
                }
            }
        }

        return sqlOptions;
    }
}